```
애플리케이션과 데이터베이스는 네트워크 통신이 발생하고 시간적 비용이 크다.
따라서 잦은 조회등의 발생에서 효율적인 개선을 위해 캐시의 개념을 사용한다

1차 캐시 조회 -> miss -> 2차 캐시 조회 -> miss -> db조회
```

### 영속성 컨텍스트
```
먼저 영속성 컨텍스트에 대해 정리하고가자.
```
```
영속성 컨텍스트는 데이터베이스와 애플리케이션 중간에 위치한 메모리 저장소이다.
내부 데이터는 HashMap으로 구성되어 id : entity로 저장된다.

영속 객체라 DB 데이터에 매핑되는 메모리상의 객체로
@Entity를 활용하는 객체이자 엔티티 매니저가 관리하며 변경을 추적하는 대상이 되고
영속성 컨텍스트는 이러한 영속 객체르 관리한다


영속성 컨텍스트에 보관되는 객체는?
- 응용 프로그램의 엔티티 매니저에의해 저장한 객체
- 응용 프로그램의 엔티티 매니저에의해 디비로부터 불려온 객체
```
- EMF / entityManagerFactory
```
애플리케이션당 하나의 엔티티 매니저 팩토리 / entityManagerFactory가 생성되며
emf는 디비 커넥션풀이라던가 디비 연동에 있어서 필요한 자원을 생성하는 작업 진행
엔티티 매니저 또한 emf가 생성
⭐️불변 객체로 스레드 세이프하다.
```
- EM / EntityManager는
```
EntityManager는 실제 디비 활용 작업을 수행하는데
스레드 세이프하지않고 각자 고유한 scope를 갖기 때문에 보통 한 스레드에서 하나만 생성하며
트랜잭션위에서만 제대로 동작한다.

entityManager는 특이한 성질을 갖는데 바로 DB connection을 LAZY상태로 가져간다!!!!
즉 entityManager는 트랜잭션 커밋시점에 디비에 반영할때 그때서야 db connection을 얻어 사용한다.

⭐️그리고 영속성 컨텍스트를 관리하는 주체가 바로 엔티티 매니저
```
- 영속성 컨텍스트
```
영속성 컨텍스트는 트랜잭션에 종속적으로!!!! 
트랜잭션 실행시 생성 / 트랜잭션 종료시 소멸한다.
이를 관리하는 주체가 entityManager고 entityManager의 persist(), commit()등의 매서드가 바로
영속성 컨텍스트 관련 api
```

### 1차 캐시
```
jpa는 명령에 대해 데이터베이스 접근 전 1차 캐시 즉 영속성 컨텍스트에서 먼저 작업을 진행한다

예를들어 em.find(~);의 경우 먼저 영속성 컨텍스트에 접근하여 데이터를 받아오고 없다면 데이터베이스에 접근한다.
따라서 만약 1차 캐시에 데이터가 없다면 아래 코드는 쿼리가 1번만 발생한다 
왜? 처음에 디비 접근해서 select한 후 그 다음은 캐싱
em.find(A);
em.find(A);

그리고 트랜잭션 커밋 시점에 flush()를 통해 모든 1차 캐시 = 영속성 컨텍스트 내용이 데이터 베이스에 반영된다.
실제로 commit() 매서드 내부에는 flush()가 포함되어 있다.
```

```
이를통해
1. 데이터베이스 접근을 최소화할 수 있다
2. 또한 같은 트랜잭션내에선 repeatable read가 가능하다.
3. 동일성 보장
  - 영속성 컨텍스트는 id / entity의 map 구조로
  - 같은 id로 영속성 컨텍스트에서 찾은 객체는 동일하다.
  
4. 쓰기 지연
  - save()의 경우도 em.persist()를 통해 영속성 컨텍스트에 저장
  - 이후 트랜잭션 커밋 시점에 commit() -> flush()로 그때 insert쿼리 발생
  
5. 변경감지
  - 영속상태의 객체를 대상으로 변경된 사항은 영속성 컨텍스트에 반영되고
  - 트랜잭션 커밋 시점에 해당 내용을 데이터베이스에 반영한다.
```
```
추가로

1차 캐시는 영속성 컨텍스트를 기준으로 서로 다른 컨텍스트간 동일성 보장 x
```
### 2차 캐시
```
1차 캐시는 결국 영속성 컨텍스트 범위의 캐시고
또한 1차 캐시 miss 후 사실 바로 db 접근이 아니라
다음 2차 캐시를 살핀다.

그래서 만약 엔티티 조회시 em.find()로 영속성 컨텍스트에서 먼저 1차 캐시를 통해 조회
-> 없다면 2차 캐시 조회
-> 있다면 2차 캐시는 자신이 보관하고 있는 엔티티를 복사하여 전달 / 즉 객체 자체를 그대로 전달하는게 아니라 복사본으 만들어 전달
-> 없다면 db 접근
```

```
덕분에 @Cacheable 사용 가능
```
